#pragma once

#include <chrono>
#include <cstdint>
#include <random>
#include <type_traits>

#include <common/common_utils.hpp>

namespace rng
{

template <typename T>
concept PRNGWrapper = requires(T t) {
    { t.prng() };
};

using SeedType = std::uint64_t;  // NOLINT

// The 'RandomNumberGenerator' class is a thin wrapper around another PRNG.
//
// Numerical simulations are the main use case for the random number generation.
// We do not need cryptographic security.
//
// Each method of seeding creates or accepts a 64-bit unsigned integer. The reasons?
//  - we do not need cryptographic security; the main use case is numerical simulations
//  - 64 bits provides enough entropy for seeding the simulations
//  - it is much easier for users to handle the storage/setting of an unsigned 64-bit
//    integer than, say, a large stream of bits
//  - we can use a consistent number of bits for any PRNG we wrap around
template <typename PRNG>
class RandomNumberGeneratorWrapper
{
public:
    // Create a PRNG seeded from a simple 64-bit unsigned integer; this is the most convenient
    // method of seeding for the user if the reproducibility of the PRNG is required
    constexpr static auto from_uint64(SeedType user_seed) noexcept -> RandomNumberGeneratorWrapper {
        return RandomNumberGeneratorWrapper(user_seed);
    }

    // Seed the PRNG using a 64-bit unsigned integer generated by the machine
    constexpr static auto from_random_uint64() noexcept -> RandomNumberGeneratorWrapper {
        std::random_device rd {};

        const auto lower_limit = std::uint64_t {0};
        const auto upper_limit = std::numeric_limits<std::uint64_t>::max();

        auto unif_dist = std::uniform_int_distribution<std::uint64_t> {lower_limit, upper_limit};
        const auto rand_seed = unif_dist(rd);

        return RandomNumberGeneratorWrapper(rand_seed);
    }

    // Seed the PRNG using the number of milliseconds since Unix time (Jan 1, 1970, 00:00:00 UTC)
    constexpr static auto from_time_since_epoch() noexcept -> RandomNumberGeneratorWrapper {
        using namespace std::chrono;  // NOLINT; ignore complaint about std::chrono namespace
        const auto clock = steady_clock::now();
        const auto ms_since_epoch = duration_cast<milliseconds>(clock.time_since_epoch());

        const auto time_seed = static_cast<std::uint64_t>(ms_since_epoch.count());

        return RandomNumberGeneratorWrapper(time_seed);
    }

    constexpr auto seed() const noexcept -> SeedType {
        return m_seed;
    }

    // NOTE: using the PRNG changes its internal state; the getter to the PRNG cannot be 'const'
    constexpr auto prng() noexcept -> PRNG& {
        return m_prng;
    }

private:
    SeedType m_seed;
    PRNG m_prng;

    // NOLINTNEXTLINE; turn off RNG seed warning, we have accepted that the seeding is weak
    constexpr explicit RandomNumberGeneratorWrapper(SeedType pseed)
        : m_seed {pseed}
    {
        if constexpr (std::is_same_v<PRNG, std::mt19937>) {
            std::seed_seq mtseed {pseed};
            m_prng.seed(mtseed);
        }
        else {
            static_assert(common_utils::always_false<PRNG>::value, "Invalid PRNG entered into wrapper.");
        }
    }
};

}  // namespace rng
